<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Ruby for C# Programmers</title>

    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootswatch/3.2.0/spacelab/bootstrap.min.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/dark.min.css">
    <link rel="stylesheet" href="public/css/app.css"/>

    <script type="text/javascript" src="public/components/jquery/dist/jquery.min.js"></script>
    <script type="text/javascript" src="public/components/bootstrap/dist/js/bootstrap.min.js"></script>

    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js"></script>

    <script type="text/javascript" src="public/components/angular/angular.min.js"></script>
    <script type="text/javascript" src="public/js/app.js"></script>
</head>
<body ng-app="tut" ng-controller="IndexCtrl">
    <div class="container">
        <div class="row">

            <div class="col-sm-2 toc">
                <div class="panel panel-default" data-spy="affix">
                <div class="panel-body">
                    <ul class="nav">
                        <li><a href="#intro">Intro</a></li>
                        <li>
                            <a href="#structure">Structure</a>
                            <ul>
                                <li><a href="#comments">Comments</a></li>
                                <li><a href="#identifiers">Identifiers</a></li>
                                <li><a href="#data">Data</a></li>
                                <li><a href="#whitespace">Whitespace</a></li>
                            </ul>
                        </li>
                        <li><a href="#data-types">Data Types</a>
                            <ul>
                                <li><a href="#strings">Strings</a></li>
                                <li><a href="#numbers">Numbers</a></li>
                                <li><a href="#arrays">Arrays</a></li>
                                <li><a href="#hashes">Hashes</a></li>
                                <li><a href="#symbols">Symbols</a></li>
                                <li><a href="#ranges">Ranges</a></li>
                            </ul>
                        </li>
                        <li>
                            <a href="#methods">Methods</a>
                            <ul>
                                <li><a href="#argument-defaults">Argument defaults</a></li>
                                <li><a href="#argument-params">Argument params</a></li>
                                <li><a href="#array-params">Array params</a></li>
                                <li><a href="#named-parameters">Named parameters</a></li>
                                <li><a href="#lambda-parameters">Lambda parameters</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
                </div>
            </div>

            <div class="col-sm-10 scroll-content">

                <h1 id="intro">Ruby for C# Programmers</h1>
                <p>
                    There are plenty of good books on the Ruby programming language. However many of the concepts required to
                    program in Ruby are identical or have analogies in C#. If you already know c# then, lots of stuff doesn't
                    need to be explained to you or could be quickly explained simply by saying this is Ruby's equivalent of
                    Foo in c#/.NET or "these work just like in c# except a, b and c".
                </p>
                <p>
                    This is mainly a <i>personal diary</i> for me while I'm learning Ruby, but there is some small chance that
                    it might help other c# devs out there who are also jumping ship.
                </p>

                <h2 id="structure">Structure and Execution</h2>

                <h3 id="comments">Comments</h3>
                <h4>Single line comment</h4>
                <code-block lang="csharp">//</code-block>
                <code-block lang="ruby">#</code-block>

                <h4>Multi-line comment</h4>
                <code-block lang="csharp">
                    /* I'm a c# multi
                    line comment */
                </code-block>
                <code-block lang="ruby">
                    =begin I'm a ruby multi
                    line comment
                    =end
                </code-block>
                <p>
                    Typically Ruby just prefixes multiple lines with <code>#</code>.
                    The <code>=begin..=end</code> syntax is actually designed to be
                    used for embedding documents but could technically be used for
                    multi-line comments in the same way as <code>/*...*/</code> in c#.
                </p>

                <h3 id="identifiers">Identifiers</h3>
                <h4>Constants</h4>
                <code-block lang="csharp">const FOO_BAR = 5;</code-block>
                <code-block lang="ruby">FooBar = 5</code-block>
                <p>
                    In ruby, identifiers starting with capital letters are implicitly constants.
                </p>

                <h4>Variables</h4>
                <code-block lang="csharp">var fooBar = 5;</code-block>
                <code-block lang="ruby">foo_bar = 5</code-block>
                <p>
                    C# identifiers can be prefixed with @ signs and can contain unicode escape sequences.
                </p>
                <p>
                    The ruby convention is to separate multiple words with an underscore.
                    Ruby identifiers can contain actual unicode characters. Additionally, in ruby:
                </p>
                <ul>
                    <li><code>$</code> prefixes <b>global variables</b></li>
                    <li><code>@</code> prefixes <b>instance variables</b></li>
                    <li><code>@@</code> prefixes <b>class variables</b></li>
                    <li><code>?</code> suffixes methods that <b>return a boolean</b></li>
                    <li><code>!</code> suffixes methods that alter their parameters (like <code>ref/out</code> parameters in c#)</li>
                </ul>
                <p>
                    For example:
                </p>
                <code-block lang="ruby">
                    # A global variable
                    @data           # An instance variable
                    @@counter       # A class variable
                    empty?          # A Boolean-valued method or predicate
                    sort!           # In-place alternative to regular sort
                    timeout=        # A method invoked by assignment
                </code-block>

                <h3 id="data">Data</h3>

                <code-block lang="csharp">/* ...resource files */</code-block>
                <code-block lang="ruby">__END__</code-block>
                <p>
                    When on a line by itself, the <code>__END__</code> keyword in ruby marks the end of the program and the beginning of
                    a data section. In C# I guess you'd use resource files where you might use data blocks in ruby.
                </p>


                <h3 id="whitespace">Whitespace</h3>
                <h4>Statement terminator</h4>
                <code-block lang="csharp">;</code-block>
                <code-block lang="ruby">;</code-block>
                <p>
                    Only required in ruby when more than one statement appears on a single line. If the
                    code on a single line in ruby is syntactically complete then the new line is implicitly
                    the statement terminator.
                </p>
                <p>
                    Ruby program behave differently depending on where you insert a newline. For example, the
                    following code adds x and y and assigns the sum to total:
                </p>
                <code-block lang="ruby">
                    total = x +     # Incomplete expression, parsing continues
                        y
                </code-block>
                <p>
                    But this code assigns x to total, and then evaluates y, doing nothing with it:
                </p>
                <code-block lang="ruby">
                    total = x  # This is a complete expression
                        + y      # A useless but complete expression
                </code-block>

                <h2 id="data-types">Data types</h2>
                <h3 id="strings">Strings</h3>
                <h4>Character literals</h4>
                <code-block lang="csharp">x = 'c';</code-block>
                <code-block lang="ruby">x = ?c</code-block>
                <p>
                    A <code>?</code> operator followed by any character will be treated as a character literal in ruby.
                    In Ruby 1.9 and later a character literal is simply stored/interpreted as a string literal
                    consisting of a single character... so <code>?a</code> is the same as <code>'a'</code>
                </p>

                <h4>String literals</h4>
                <code-block lang="csharp">"Hello"</code-block>
                <code-block lang="ruby">'World'</code-block>

                <h4>Multi line string literals</h4>
                <code-block lang="csharp">
                    message =
                        "This is a \r\n" +
                        "multi-line string literal.";
                </code-block>
                <code-block lang="ruby">
                    message =
                        "This is a
                        multi-line string literal."
                </code-block>

                <p>
                    Ruby actually has quite a few ways to do multiline strings. Another option, which lets you use
                    things like double quotes without having to worry about escaping them is to use Unix style HERE
                    documents. For example (although any arbitrary tag can be used instead of HERE):
                </p>
                <code-block lang="ruby">
                    document = &lt;&lt;HERE
                    I'm a "string literal".
                    After my second line I die!!!
                    HERE
                </code-block>

                <h4>Format strings</h4>
                <p>
                    Format strings can be done a couple of ways in Ruby.
                </p>
                <p>
                    One is <i>interpolation</i> - strings surrounded by double quotes can contain expressions that will
                    be interpolated. Unlike the string.Format method in c#, interpolated strings in ruby don't need any
                    explicit arguments - any valid ruby expression can be used in a string interpolation.
                </p>
                <code-block lang="ruby">
                    target = 'World!'
                    "Hello #{target}!"
                </code-block>
                <p>
                    Another is to use the equivalent of a printf or sprintf function (from C). This lets you specify
                    formatting when injecting arguments. Ruby lets you do this by following the string with a % operator
                    and then the arguments for the printf function.
                </p>
                <code-block lang="ruby">
                    "Hello %s" % target
                    "%s: %f" % ["pi", Math::PI];
                </code-block>

                <h4>Regular expressions</h4>
                <code-block lang="csharp">
                    new Regex(@"[a-z]\d+");
                </code-block>
                <code-block lang="ruby">
                    /[a-z]\d+/
                </code-block>

                <h4>String manipulation</h4>
                <code-block lang="csharp">
                    var x = "Hello";
                    x += " there" + " world!";
                </code-block>
                <code-block lang="ruby">
                    x = "Hello"
                    x << " there" << " world!"
                </code-block>
                <p class="clearfix">
                    The <code>&lt;&lt;</code> operator in Ruby, when used with strings is roughly equivalent to the
                    <code>+=</code> operator in c#, except that it can be chained. Also, the <code>&lt;&lt;</code>
                    operator will accept character literals or integers (which will be treated as character codes) to
                    append individual characters to a string.
                </p>
                <p>
                    Ruby lets you use negative indexes to reference individual characters in a string and also lets you
                    assign characters or strings to string indexes in order to append, insert or delete characters/strings
                    from an existing string... something that would need to be done with string.Replace in c#.
                </p>
                <code-block lang="csharp">
                    var s = "hello";
                    s[s.Length - 2];
                    s = s.Remove(s.Length - 1);
                    s = s.Substring(0, s.Length - 1) + "p!";
                </code-block>
                <code-block lang="ruby">
                    s = 'hello'
                    s[-2]
                    s[-1] = ""    # Deletes last character: "Hell"
                    s[-1] = "p!"  # Replaces last character with p!
                </code-block>
                <p>
                    Bracket notation also lets you get substrings using an index + length (similar to the string.Substring
                    method in C#). Negative indices may be used when doing this, but not negative lengths.
                </p>
                <code-block lang="ruby">
                    x = 'yellow'
                    y = x[3,3]     # y == 'low'
                    y = x[-3,3]    # y == 'low'
                    x[0,3] = 'b'   # x == 'blow'
                    x[1,0] = 'e'   # x == 'below'
                </code-block>
                <p>
                    Ruby strings can also be indexed using ranges and other strings. Ranges, like bracket notation,
                    accept two integers however both are indices. Indexing using other strings is like the
                    string.Replace method in c#.
                </p>
                <code-block lang="csharp">
                    var x = "yellow";
                    var y = x.Substring(3, 3);

                    x = x.Replace("ell", "");
                </code-block>
                <code-block lang="ruby">
                    x = 'yellow'
                    y = x[3...5]    # y == 'lo'
                    y = x[3..5]     # y == 'low'
                    x['ell'] = ''   # x == 'yow'
                </code-block>
                <p>
                    Regular expressions indexers can be used, which yields the first substring matching the regular
                    expression... and again, these can be assigned to in order to perform a string.Replace:
                </p>
                <code-block lang="ruby">
                    s = 'damn it!'
                    s[/[aeiou]/] = '*'      # 'd*mn it!'
                </code-block>
                <p>
                    Ruby also has some other operators that can be used with strings, which have no real equivalent in C#.
                </p>
                <code-block lang="ruby">
                    ellipsis = '.' * 3      # Evaluates to '...'
                </code-block>

                <h3 id="numbers">Numbers</h3>
                <h4>Integer literals</h4>
                <code-block lang="csharp">1000000000</code-block>
                <code-block lang="ruby">1_000_000_000</code-block>
                <p>
                    Ruby allows underscores in integer literals, for readibility
                </p>

                <h4>Bases</h4>
                <code-block lang="csharp">
                    0xFF
                    Convert.ToInt32("0377", 8);
                    Convert.ToInt32("11111111", 2);
                </code-block>
                <code-block lang="ruby">
                    0xFF           # 255 in hexadecimal
                    0377           # Octal
                    0b1111_1111    # Binary
                </code-block>
                <p>
                    c# doesn't natively support bases other than 10 and 16 - the Convert helper needs to be used for other bases
                    In ruby, an integer literal starting with a zero and consisting of more than one digit will be interpreted in
                    some base other than 10.
                </p>

                <h4>Floating point literals</h4>
                <code-block lang="csharp">
                    3.14F   // float
                    3.14    // double

                </code-block>
                <code-block lang="ruby">
                    -3.14     # real number
                    6.02e23   # scientific notation
                    6_000.01  # 6,000.01
                </code-block>
                <p>Ruby supports scientific notation and underscores for readibilty</p>

                <h4>Integer arithmetic</h4>
                <code-block lang="csharp">
                    -7 / 3            // -2
                    7 / 0             // throws DivideByZeroException
                    -7 % 2            // -1
                    7 % -2            // 1
                    Math.Pow(2, 3);   // 8
                </code-block>
                <code-block lang="ruby">
                    -7 / 3;       // x == -3
                    7 / 0;        // throws ZeroDivisionError
                    -7 % 2        // 3
                    7 % -2        // -3
                    2**3          // 8
                </code-block>
                <p>
                    C# rounds towards zero when performing integer division and modulo operations.
                    In c# the sign of the modulo result is always the asme as that of the first operand.
                    C# doesn't have a power operator so the Math class needs to be used instead
                </p>
                <p>
                    Ruby rounds towards negative infinity when performing integer division and modulo operations.
                    In ruby the sign of the modulo result is always the asme as that of the second operand.
                    Ruby uses ** as a power operator.
                </p>

                <h4>Floating point arithmetic</h4>
                <code-block lang="csharp">
                    3.1F / 0;   // throws DivideByZeroException
                    3.1 / 0;    // x == double.NaN
                    0.0 / 0;    // x == double.NaN
                </code-block>
                <code-block lang="ruby">
                    3.1 / 0     // x == Infinity
                    3.1 / 0     // x == Infinity
                    0.0 / 0     // x == NaN
                </code-block>
                <p>
                    c# throws divide by zero exceptions for integers and floats but not for doubles.
                </p>
                <p>
                    Ruby throws zero division errors for integers but not floats and gives different results for divide by
                    zero when dividing a non-zero number by zero vs dividing zero by zero.
                </p>

                <h3 id="arrays">Arrays</h3>
                <p>
                    Arrays in Ruby are rather like strings and come with all the same bells and whistles (negative
                    indexers, range indexers and assignment to achieve inserts and deletes). Ruby arrays are dynamic and
                    can contain elements of mixed types (including other arrays - resulting in the equivalent of C# multi
                    dimensional arrays).
                </p>
                <code-block lang="ruby">
                    a = [0, 1, 4, 9, 16]    # Array holds the squares of the indexes
                    a[0] = "zero"           # a is ["zero", 1, 4, 9, 16]
                    a[-1] = 1..16           # a is ["zero", 1, 4, 9, 1..16]
                    a[8] = 64               # a is ["zero", 1, 4, 9, 1..16, nil, nil, nil, 64]
                </code-block>
                <p>
                    <span class="label label-info">Note</span> On that last line ruby does something implicilty that would
                    require a couple of lines in c#... if you assign a value to an index beyond the end of the array
                    length, it automatically increases the size of the array (initializing all the new elements as nil)
                    and then performs the assignment.
                </p>
                <p>
                    Ruby also includes a special-case syntax for expressing array literals whose elements are short
                    strings without spaces:
                </p>
                <code-block lang="ruby">
                    words = %w[this is a test]  # Same as: ['this', 'is', 'a', 'test']
                    open = %w| ( [ { < |        # Same as: ['(', '[', '{', '<']
                    white = %W(\s \t \r \n)     # Same as: ["\s", "\t", "\r", "\n"]
                </code-block>
                <p>
                    Ruby has some cool operators for working with arrays that replace many lines of complex method calls
                    in c#.
                </p>
                <code-block lang="ruby">
                    a = [1, 2, 3] + [4, 5]                          # [1, 2, 3, 4, 5]
                    b = ['a', 'b', 'c', 'b', 'd'] - ['b', 'c']      # ['a', 'd']
                    c = []                                          # Start with an empty array
                    c << 1                                          # c is [1]
                    c << 2 << 3                                     # c is [1,2,3]
                    d = [0] * 8                                     # [0, 0, 0, 0, 0, 0, 0, 0]
                </code-block>
                <p>
                    Boolean operators <code>|</code> and <code>&</code> and uses them for union and intersection.
                    <code>|</code> concatenates its arguments and then removes all duplicate elements from the
                    result. <code>&</code> returns an array that holds elements that appear in both of the operand
                    arrays. The returned array does not contain any duplicate elements:
                </p>
                <code-block lang="ruby">
                    a = [1, 1, 2, 2, 3, 3, 4]
                    b = [5, 5, 4, 4, 3, 3, 2]
                    a | b    # [1, 2, 3, 4, 5]: duplicates are removed
                    b | a    # [5, 4, 3, 2, 1]: elements are the same, but order is different
                    a & b    # [2, 3, 4]
                    b & a    # [4, 3, 2]
                </code-block>


                <h3 id="hashes">Hashes</h3>
                <p>
                    A hash in Ruby is roughly equivalent to a Dictionry in C#.
                </p>
                <code-block lang="csharp">
                    var numbers = new Dictionary<string, int>();
                    numbers["one"] = 1;
                    numbers["two"] = 2;
                    numbers["three"] = 3;
                    var sum = numbers["one"] + numbers["two"];
                </code-block>
                <code-block lang="ruby">
                    numbers = Hash.new
                    numbers["one"] = 1
                    numbers["two"] = 2
                    numbers["three"] = 3
                    sum = numbers["one"] + numbers["two"]
                </code-block>
                <p>
                    Hash literals also exist to allow easy initialization:
                </p>
                <code-block lang="ruby">
                    numbers = { "one" => 1, "two" => 2, "three" => 3 }
                </code-block>

                <h3 id="symbols">Symbols</h3>
                <p>
                    Although any object can be used as the hash keys in Ruby, typical <strong>symbols</strong> are used.
                    These are immutable interned strings that are written as colon prefixed identifiers:
                </p>
                <code-block lang="ruby">
                    numbers = { :one => 1, :two => 2, :three => 3 }
                </code-block>
                <p>
                    Ruby 1.9 also supports a more compact hash initialization syntax when the keys are all symbols:
                </p>
                <code-block lang="ruby">
                    numbers = { one: 1, two: 2, three: 3 }  # same as { :one => 1, :two => 2, :three => 3 }
                </code-block>
                <p>
                    Note that symbols can also be formed by prefixing strings with colons (rather than identifiers),
                    which lets you create symbols with whitespace and "dynamic" symbols. Symbols also have a
                    <code>%s</code> literal syntax that allows arbitrary delimiters in the same way that <code>%q</code>
                    and <code>%Q</code> can be used for string literals:
                </p>
                <code-block lang="ruby">
                    :'a long symbol'    # Quotes are useful for symbols with spaces
                    s = "string"
                    sym = :"#{s}"       # The Symbol :string
                    %s["]               # Same as :'"'
                </code-block>
                <p>
                    Symbols are often used to refer to method names in reflective code. For example, the following code
                    tests whether a given object responds to a specified method, and, if so, invokes that method:
                </p>
                <code-block lang="ruby">
                    name = :size
                    if o.respond_to? name
                        o.send(name)
                    end
                </code-block>

                <h3 id="ranges">Ranges</h3>
                <p>
                    Ruby lets you define either inclusive ranges (using two dots) or exclusive ranges (using three dots):
                </p>
                <code-block lang="ruby">
                    1..10      # The integers 1 through 10, including 10
                    1.0...10.0 # The numbers between 1.0 and 10.0, excluding 10.0 itself
                </code-block>
                <p>
                    The primary purpose for ranges is comparison:  to be able to determine whether a value is in or
                    out of the range.
                </p>
                <code-block lang="ruby">
                    cold_war = 1945..1989
                    cold_war.include? birthdate.year
                </code-block>
                <p>
                    An important secondary purpose is iteration:  if the class of the endpoints of a range defines a
                    <code>succ</code> method (for successor), then there is a discrete set of range members, and they
                    can be iterated with <code>each</code>, <code>step</code>, and <code>Enumerable</code> methods.
                    Consider the range <code>'a'..'c'</code>, for example:
                </p>
                <code-block lang="ruby">
                    r = 'a'..'c'
                    r.each {|l| print "[#{l}]"}     # Prints "[a][b][c]"
                    r.step(2) { |l| print "[#{l}]"} # Prints "[a][c]"
                    r.to_a                          # => ['a','b','c']: Enumerable defines to_a
                </code-block>

                <h2 id="methods">Methods</h2>
                <h3 id="argument-defaults">Argument defaults</h3>
                <code-block lang="csharp">
                    string Prefix(string s, int len = 1)
                    {
                        return s.SubString(0,len);
                    }
                </code-block>
                <code-block lang="ruby">
                    def prefix(s, len=1)
                        s[0,len]
                    end
                </code-block>

                <p>
                    In Ruby, argument defaults can be any arbitrary expressions, and can refer to instance variables or
                    to previous parameters in the parameter list. For example:
                </p>
                <code-block lang="csharp">
                    string Suffix(string s, int? len = null)
                    {
                        len = len ?? 1;
                        return s.SubString(s.Length - len);
                    }
                </code-block>
                <code-block lang="ruby">
                    def suffix(s, index=s.size-1)
                        s[index, s.size-index]
                    end
                </code-block>
                <p>
                    Doing this in c# is a bit messier... above it's done using a nullable parameter and setting the
                    "default" value of that parameter in the method body, when it's null (i.e. the signature default).
                    Another option would be to use method overloading. Either way is more verbose than the Ruby syntax.
                </p>


                <h3 id="argument-params">Argument params</h3>
                <code-block lang="csharp">
                    int Max(int first, params int[] rest)
                    {
                        int max = first;
                        foreach(var next in rest)
                            if (next > max)
                                max = next;
                        return max;
                    }
                </code-block>
                <code-block lang="ruby">
                    def max(first, *rest)
                        max = first
                        rest.each {|x| max = x if x > max }
                        max
                    end
                </code-block>
                <p>
                    Note that the c# code isn't generic like the Ruby code... this would be possible using c# generics and
                    the <code>IComparable</code> interface but generics.
                </p>

                <h3 id="array-params">Array params</h3>
                <p>
                    One major difference between the c# and ruby implementations is that arrays can be passed to the c#
                    implementation as if the <code>params</code> keyword were not present. In Ruby, doing this would
                    cause the array to be passed as the first (and only) "param" argument. In order to pass the
                    individual elements of an array separately to a method that accepts a variable number of parameters
                    in Ruby, you need to use the * (splat) operator:
                </p>
                <code-block lang="csharp">
                    int[] rest = {2,3,4};
                    var max = Max(1, rest); // max = 4
                </code-block>
                <code-block lang="ruby">
                    rest = [2,3,4]
                    _max = max(1,*rest)     # _max = 4
                </code-block>

                <h3 id="named-parameters">Named parameters (method invokation)</h3>
                <p>
                    Ruby doesn't have this so it has to be fudged using something like a hash array:
                </p>
                <code-block lang="csharp">
                    int Area(int height, int width)
                    {
                        return height * width;
                    }

                    var area = Area(height: 4, width: 5);
                </code-block>
                <code-block lang="ruby">
                    def area(args)
                        height = args[:height]
                        width = args[:width]
                        height * width
                    end

                    _area = area({:height=>4, :width=>5})
                </code-block>
                <p>
                    However, since this is a fairly common 'trick' if you have methods with lots of arguments, Ruby lets
                    you omit the curly brackets and you can use the compact hash initialization syntax:
                </p>
                <code-block lang="ruby">
                    _area = area(height:4, width:5)
                </code-block>
                <p>
                    So calling the methods can look exactly like c#. However in the implementation of the method, Ruby
                    has to "extract" the named methods from the argument list... and if you declare/implement a method
                    like this in ruby then you <em>have</em> to call it with 'named arguments' - there's no way to just
                    pass arguments (outside of a hash).
                </p>

                <h3 id="lambda-parameters">Lambda parameters</h3>
                <code-block lang="csharp">
                    void Enact(int count, Action&lt;int&gt; act)
                    {
                        for(i = 1; i <= count; i++)
                            act(i);
                    }

                    Enact(5, x => Console.WriteLine(x));
                </code-block>
                <code-block lang="ruby">
                    def enact(count)
                        for element in 1..count
                            yield element
                        end
                    end

                    enact(5) {|x| puts x }
                </code-block>
                <p>
                    In Ruby the <code>yield</code> keyword executes an implicit/hidden <strong>block</strong> parameter
                    that is roughly equivalent to the c# Func delegates. If you want to be able to pass the block to
                    a nested function, then the block parameter can be explicitly declared:
                </p>
                <code-block lang="csharp">
                    void DoubleAct(int count, Action&lt;int&gt; act)
                    {
                        Enact(count, act);
                        Enact(count, act);
                    }

                    DoubleAct(5, x => Console.WriteLine(x));
                </code-block>
                <code-block lang="ruby">
                    def double_act(count, &act)
                        enact(count, &act)
                        enact(count, &act)
                    end

                    double_act(5) {|x| puts x }
                </code-block>
                <p>
                    If you need to pass multiple <em>blocks</em> to a method in Ruby, this can be done by passing
                    <code>Proc</code> objects rather than blocks. You still kind of get lambda syntax when doing this:
                </p>
                <code-block lang="ruby">
                    def do_two_things(target, action_one, action_two)
                        action_one.call(target)
                        action_two.call(target)
                    end

                    one = Proc.new {|x| puts x }
                    two = Proc.new {|x| puts x**2 }
                    do_two_things(5, one, two)
                </code-block>

                <p>
                    Another option is lambdas like so:
                </p>
                <code-block lang="ruby">
                    succ = ->(x){ x+1 }
                    succ.call(2)    # => 3
                </code-block>
                <p>
                    The result is something that much more closely matches the c# way of doing this and is just as
                    concise:
                </p>
                <code-block lang="csharp">
                    void DoTwoThings(int target, Action&lt;int&gt; actionOne, Action&lt;int&gt; actionTwo)
                    {
                        actionOne(target);
                        actionTwo(target);
                    }

                    DoTwoThings(5, x => Console.WriteLine(x), x => Console.WriteLine(x*x));
                </code-block>
                <code-block lang="ruby">
                    def do_two_things(target, action_one, action_two)
                        action_one.call(target)
                        action_two.call(target)
                    end

                    do_two_things(5, -> x { puts x }, -> x { puts x**2 })
                </code-block>
                <p>
                    As with methods, lambdas can make some of their arguments optional by giving them default values and,
                    as with block, local variables can be specified in the lambda declaration (to make sure the lambda
                    doesn't inadvertedly overwrite variables outside of the block).
                </p>
                <code-block lang="ruby">
                    # This lambda has an optional "factor" argument
                    zoom = ->(x,y,factor=2) { [x*factor, y*factor] }

                    # This lambda takes 2 args and declares 3 local vars
                    f = ->(x,y; i,j,k) { ... }
                </code-block>
                <p>
                    <span class="label label-warning">Warning</span> Procs and Lambdas in Ruby are not the same thing.
                    Procs operate more like blocks (if a Proc/block includes a <code>return</code> statement this causes
                    control to exit from the method that is calling the block. Lambdas are more like methods - a
                    <code>return</code> statement in a lambda merely exits from the lambda itself.
                </p>
            </div>
        </div>
    </div>
</body>
</html>